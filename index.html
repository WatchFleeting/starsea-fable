<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="AI预言生成器 - 神秘的文字转换与冥想体验">
    <title>AI 预言生成器</title>
    
    <!-- 预加载关键CSS资源，提升字体加载性能 -->
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+SC:wght@300;500;700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" as="style">
    
    <!-- 引入Tailwind CSS框架 -->
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    
    <!-- 优化字体加载：预连接字体服务器 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <!-- 引入Google字体 -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+SC:wght@300;500;700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    
    <style>
        /* ============================================
           CSS变量定义 - 主题颜色管理
           ============================================ */
        :root {
            --color-primary: #050505;         /* 主背景色 */
            --color-secondary: #1a103c;       /* 次要背景色 */
            --color-accent: #cfc09f;          /* 强调色-亮金色 */
            --color-accent-dark: #3a2c0f;     /* 强调色-暗金色 */
            --color-border: rgba(255, 215, 0, 0.1); /* 边框颜色 */
            --color-text: #e2e8f0;            /* 主文字颜色 */
            --color-text-muted: #a0aec0;      /* 次要文字颜色 */
        }

        /* ============================================
           基础样式
           ============================================ */
        body {
            background-color: var(--color-primary);
            color: var(--color-text);
            font-family: 'Noto Serif SC', 'Playfair Display', serif;
            min-height: 100vh;                /* 确保页面占满整个视口高度 */
            margin: 0;
            overflow-x: hidden;               /* 隐藏水平滚动条 */
            position: relative;
        }

        /* ============================================
           神秘边框效果 - 主要容器样式
           ============================================ */
        .mystic-border {
            position: relative;
            background: rgba(20, 20, 25, 0.85); /* 半透明深色背景 */
            backdrop-filter: blur(12px);        /* 背景模糊效果 */
            border: 1px solid var(--color-border);
            box-shadow: 
                0 0 20px rgba(0, 0, 0, 0.7),    /* 外阴影 */
                inset 0 1px 0 rgba(255, 255, 255, 0.05); /* 内发光效果 */
            will-change: transform, opacity;     /* 提示浏览器优化动画性能 */
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); /* 平滑过渡动画 */
        }

        /* 鼠标悬停时的卡片效果 */
        .mystic-border:hover {
            transform: translateY(-2px);         /* 轻微上浮 */
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.9),  /* 加深阴影 */
                inset 0 1px 0 rgba(255, 255, 255, 0.1); /* 增强内发光 */
        }

        /* 左上角和右下角装饰性边框 */
        .mystic-border::before, 
        .mystic-border::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            border: 1px solid rgba(255, 215, 0, 0.5);
            transition: all 0.3s ease;
            pointer-events: none;               /* 防止干扰鼠标事件 */
        }

        /* 左上角边框（只有上边和左边） */
        .mystic-border::before { 
            top: -1px; 
            left: -1px; 
            border-right: none; 
            border-bottom: none; 
        }
        
        /* 右下角边框（只有下边和右边） */
        .mystic-border::after { 
            bottom: -1px; 
            right: -1px; 
            border-left: none; 
            border-top: none; 
        }

        /* ============================================
           金色渐变文字效果
           ============================================ */
        .gold-text {
            background: linear-gradient(135deg, 
                var(--color-accent) 0%, 
                #ffecb3 30%, 
                #b59a5c 70%, 
                var(--color-accent-dark) 100%);
            -webkit-background-clip: text;       /* 将背景裁剪为文字形状 */
            background-clip: text;               /* 标准属性 */
            -webkit-text-fill-color: transparent; /* 隐藏文字颜色，显示背景渐变 */
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); /* 添加阴影增强可读性 */
        }

        /* ============================================
           输入区域样式
           ============================================ */
        .input-area {
            background: rgba(10, 10, 15, 0.5);   /* 半透明深色背景 */
            border: 1px solid #3a3a4a;           /* 中灰色边框 */
            color: #d1d5db;                      /* 浅灰色文字 */
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); /* 平滑过渡 */
            caret-color: #a78bfa;                /* 输入光标颜色（紫色） */
        }

        /* 输入框聚焦状态 */
        .input-area:focus {
            border-color: #8b5cf6;               /* 紫色边框 */
            box-shadow: 
                0 0 0 3px rgba(139, 92, 246, 0.1), /* 外发光效果 */
                0 0 20px rgba(139, 92, 246, 0.3);  /* 弥散阴影 */
            background: rgba(10, 10, 15, 0.7);   /* 加深背景 */
        }

        /* ============================================
           神秘按钮样式
           ============================================ */
        .btn-mystic {
            background: linear-gradient(135deg, #2e1065 0%, #4c1d95 50%, #2e1065 100%);
            border: 1px solid #7c3aed;           /* 紫色边框 */
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            isolation: isolate;                  /* 创建新的堆叠上下文 */
        }

        /* 按钮流光效果 */
        .btn-mystic::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;                         /* 初始位置在左侧外部 */
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.1), 
                transparent);
            transition: left 0.7s ease;          /* 从左到右移动动画 */
            z-index: 1;
        }

        /* 鼠标悬停时触发流光效果 */
        .btn-mystic:hover::before {
            left: 100%;                          /* 移动到右侧外部 */
        }

        /* 鼠标悬停时的按钮状态 */
        .btn-mystic:hover {
            transform: translateY(-3px);         /* 上浮效果 */
            box-shadow: 
                0 10px 25px rgba(124, 58, 237, 0.4), /* 紫色阴影 */
                0 0 15px rgba(124, 58, 237, 0.2);    /* 弥散光晕 */
        }

        /* 按钮按下状态 */
        .btn-mystic:active {
            transform: translateY(-1px);         /* 轻微回弹 */
            transition-duration: 0.1s;           /* 快速过渡效果 */
        }

        /* ============================================
           关键帧动画定义
           ============================================ */
        
        /* 淡入浮现动画 - 用于结果显示 */
        @keyframes fadeReveal {
            0% { 
                opacity: 0; 
                transform: translateY(20px) scale(0.95); /* 从下方缩小进入 */
            }
            100% { 
                opacity: 1; 
                transform: translateY(0) scale(1);      /* 恢复到正常位置和大小 */
            }
        }

        /* 闪烁流光动画 */
        @keyframes shimmer {
            0% { 
                transform: translateX(-100%) rotate(45deg); /* 从左上角开始 */
            }
            100% { 
                transform: translateX(100%) rotate(45deg);  /* 移动到右下角 */
            }
        }

        /* 漂浮动画 - 用于装饰性元素 */
        @keyframes float {
            0%, 100% { 
                transform: translateY(0);        /* 起始和结束位置 */
            }
            50% { 
                transform: translateY(-10px);    /* 中间位置上浮 */
            }
        }

        /* 柔和脉动动画 */
        @keyframes pulse-gentle {
            0%, 100% { 
                opacity: 0.8;                    /* 透明度变化 */
            }
            50% { 
                opacity: 1;                      /* 最明显状态 */
            }
        }

        /* ============================================
           动画应用类
           ============================================ */
        .reveal-anim {
            animation: fadeReveal 0.8s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        .float-anim {
            animation: float 3s ease-in-out infinite; /* 无限循环 */
        }

        /* ============================================
           特殊字体类
           ============================================ */
        .font-cinzel {
            font-family: 'Cinzel', serif;        /* 装饰性衬线字体 */
        }

        /* ============================================
           冥想模式样式
           ============================================ */
        .meditation-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* 径向渐变背景 */
            background: radial-gradient(ellipse at center, 
                rgba(26, 16, 60, 0.95) 0%, 
                rgba(5, 5, 5, 1) 70%);
            z-index: 100;                        /* 确保在最上层 */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;                /* 默认不可交互 */
            transition: opacity 0.5s ease;       /* 淡入淡出过渡 */
            will-change: opacity;                /* 性能优化提示 */
        }

        /* 激活状态的冥想覆盖层 */
        .meditation-overlay.active {
            opacity: 1;
            pointer-events: all;                 /* 启用交互 */
        }

        /* 冥想圆环容器 */
        .meditation-circle {
            width: 220px;
            height: 220px;
            border-radius: 50%;                  /* 圆形 */
            border: 2px solid rgba(255, 215, 0, 0.15);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;                   /* 防止文字被选中 */
            -webkit-user-select: none;           /* Safari支持 */
            /* 径向渐变背景 */
            background: radial-gradient(circle at center, 
                rgba(26, 16, 60, 0.3) 0%,
                transparent 70%);
        }

        /* 进度环SVG容器 */
        .progress-ring {
            position: absolute;
            top: -4px;                           /* 略微超出容器 */
            left: -4px;
            width: 228px;                        /* 容器宽度+边框*2 */
            height: 228px;
            transform: rotate(-90deg);           /* 从顶部开始 */
            filter: drop-shadow(0 0 8px rgba(167, 139, 250, 0.3)); /* 发光效果 */
        }

        /* 进度环圆形路径 */
        .progress-ring circle {
            fill: transparent;                   /* 透明填充 */
            stroke: url(#gradient);              /* 使用SVG渐变 */
            stroke-width: 4;
            stroke-dasharray: 690.8;             /* 周长公式：2 * π * 半径 (110) */
            stroke-dashoffset: 690.8;            /* 初始完全隐藏 */
            transition: stroke-dashoffset 0.05s linear; /* 平滑进度更新 */
            stroke-linecap: round;               /* 圆角线帽 */
        }

        /* ============================================
           响应式设计 - 移动端适配
           ============================================ */
        @media (max-width: 640px) {
            /* 缩小冥想圆环以适应小屏幕 */
            .meditation-circle {
                width: 180px;
                height: 180px;
            }
            
            .progress-ring {
                width: 188px;
                height: 188px;
            }
            
            /* 为小屏幕添加边距 */
            .mystic-border {
                margin: 0 10px;
            }
        }

        /* ============================================
           性能优化类
           ============================================ */
        .will-change-transform {
            will-change: transform;              /* 提示浏览器将要进行变换 */
        }

        .backface-hidden {
            backface-visibility: hidden;         /* 隐藏背面，提升3D动画性能 */
        }

        /* ============================================
           加载状态动画
           ============================================ */
        .loading-dots::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite; /* 点点点动画 */
        }

        @keyframes dots {
            0%, 20% { content: '.'; }           /* 阶段1：一个点 */
            40% { content: '..'; }              /* 阶段2：两个点 */
            60%, 100% { content: '...'; }       /* 阶段3：三个点 */
        }

        /* ============================================
           粒子背景效果
           ============================================ */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;               /* 不干扰页面交互 */
            z-index: 1;                         /* 在背景层，内容下方 */
        }

        /* 单个粒子 */
        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(255, 215, 0, 0.2); /* 半透明金色 */
            border-radius: 50%;                 /* 圆形粒子 */
            animation: particle-float 20s linear infinite; /* 漂浮动画 */
        }

        /* 粒子漂浮动画 */
        @keyframes particle-float {
            0% {
                transform: translateY(100vh) rotate(0deg); /* 从屏幕底部开始 */
                opacity: 0;                               /* 完全透明 */
            }
            10% {
                opacity: 1;                               /* 快速淡入 */
            }
            90% {
                opacity: 1;                               /* 保持可见 */
            }
            100% {
                transform: translateY(-100px) rotate(360deg); /* 旋转上浮 */
                opacity: 0;                               /* 淡出 */
            }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center p-4">
    
    <!-- 粒子背景效果容器 -->
    <div id="particles" class="particles"></div>

    <!-- 主内容容器 -->
    <div class="max-w-md w-full my-auto relative z-10">
        <!-- 页头区域 -->
        <header class="text-center mb-8">
            <!-- 动态漂浮的图标容器 -->
            <div class="w-20 h-20 mx-auto mb-4 rounded-full border border-amber-900/50 flex items-center justify-center bg-black/40 shadow-[0_0_30px_rgba(120,53,15,0.4)] float-anim">
                <!-- 眼睛图标 - 象征洞察与预言 -->
                <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 text-amber-200/80" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" 
                          d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" 
                          d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                </svg>
            </div>
            <!-- 主标题 -->
            <h1 class="text-4xl font-bold mb-3 gold-text font-cinzel tracking-wider">AI 预言生成器</h1>
            <!-- 副标题/说明 -->
            <p class="text-xs text-amber-100/40 tracking-widest uppercase font-cinzel">仅供娱乐 · For Entertainment Only</p>
        </header>

        <!-- 语言切换按钮组 -->
        <div class="flex justify-center mb-6">
            <div class="flex bg-black/40 rounded-full p-1 border border-amber-900/30 relative overflow-hidden">
                <!-- 语言切换高亮指示器 -->
                <div id="langHighlight" class="absolute top-1 left-1 w-[calc(50%-4px)] h-[calc(100%-8px)] bg-gradient-to-r from-amber-900/80 to-purple-900/80 rounded-full transition-all duration-300"></div>
                <!-- 英语按钮 -->
                <button id="langEnBtn" 
                        class="relative z-10 px-5 py-2 text-sm font-cinzel font-bold text-amber-100 transition-colors w-24"
                        aria-label="Switch to English">
                    ENGLISH
                </button>
                <!-- 中文按钮 -->
                <button id="langCnBtn" 
                        class="relative z-10 px-5 py-2 text-sm font-serif font-bold text-amber-100/50 transition-colors w-24"
                        aria-label="切换到中文">
                    中文
                </button>
            </div>
        </div>

        <!-- 主卡片容器 -->
        <main class="mystic-border rounded-xl p-8">
            <!-- 输入区域 -->
            <div id="input-section">
                <!-- 输入标签 -->
                <label id="inputLabel" 
                       class="block text-amber-100/80 text-sm mb-4 text-center italic tracking-wide"
                       for="userInput">
                    "请在此表达你心中的疑虑..."
                </label>
                <!-- 多行文本输入框 -->
                <textarea 
                    id="userInput" 
                    rows="4"
                    class="input-area w-full rounded-lg p-5 text-lg mb-6 text-center placeholder-gray-600 font-serif resize-none focus:outline-none"
                    placeholder="在此输入你的问题..."
                    maxlength="200"
                    aria-label="输入你的问题"
                ></textarea>
                <!-- 字符计数器 -->
                <div class="text-xs text-gray-500 text-right mb-4">
                    <span id="charCount">0</span>/200
                </div>

                <!-- 按钮组 -->
                <div class="flex gap-4">
                    <!-- 生成预言按钮 -->
                    <button id="generateBtn" 
                            class="btn-mystic flex-1 py-4 rounded-lg text-amber-50 font-cinzel font-bold tracking-widest uppercase text-sm cursor-pointer"
                            aria-label="生成预言">
                        寻求启示
                    </button>
                    <!-- 冥想模式按钮 -->
                    <button id="meditateBtn" 
                            class="btn-mystic px-6 py-4 rounded-lg text-amber-50 font-cinzel font-bold tracking-widest uppercase text-sm cursor-pointer bg-gradient-to-br from-indigo-900/90 to-purple-900/90 border-indigo-700"
                            title="冥想模式"
                            aria-label="进入冥想模式">
                        <!-- 太阳图标，象征冥想与聚焦 -->
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                        </svg>
                    </button>
                </div>
            </div>

            <!-- 输出结果区域（默认隐藏） -->
            <div id="output-section" class="hidden mt-8">
                <div class="border-t border-white/10 pt-6 text-center reveal-anim">
                    <!-- 结果标题 -->
                    <p class="text-xs text-amber-200/60 mb-4 uppercase tracking-[0.2em] font-cinzel">The Prophecy</p>
                    <!-- 预言结果显示区域 -->
                    <div id="resultText" class="text-2xl mb-8 text-amber-50 font-cinzel leading-relaxed break-words min-h-[120px] flex items-center justify-center p-4 bg-black/20 rounded-lg border border-white/5"></div>
                    
                    <!-- 使用说明区域 -->
                    <div class="bg-black/40 p-5 rounded-xl border border-white/5 mb-6">
                        <p class="text-sm text-gray-300 italic mb-3 font-serif">
                            "去用这串文字生成图片，它们将蕴藏你的启示。"
                        </p>
                        <p class="text-xs text-amber-100/40 border-t border-white/5 pt-3">
                            * 用较旧的AI模型生成图片效果更佳，因为它们足够模糊，并且不会优化提示词。
                        </p>
                    </div>
                    
                    <!-- 结果操作按钮 -->
                    <div class="flex gap-3 justify-center">
                        <button id="copyBtn" 
                                class="px-6 py-2 text-sm text-amber-200/70 hover:text-amber-200 transition-colors border border-amber-900/30 rounded-lg hover:border-amber-900/50">
                            复制预言
                        </button>
                        <button id="resetBtn" 
                                class="px-6 py-2 text-sm text-amber-200/70 hover:text-amber-200 transition-colors border border-amber-900/30 rounded-lg hover:border-amber-900/50">
                            再次提问
                        </button>
                    </div>
                </div>
            </div>
        </main>
        
        <!-- 页脚 -->
        <footer class="text-center mt-12 opacity-40 hover:opacity-60 transition-opacity">
            <p class="text-[10px] font-cinzel tracking-widest">MYSTIC · ALGORITHM</p>
            <p class="text-[8px] text-gray-500 mt-1">v2.0 · 仅供娱乐</p>
        </footer>
    </div>

    <!-- 冥想模式全屏覆盖层 -->
    <div id="meditationOverlay" class="meditation-overlay" aria-hidden="true">
        <!-- SVG渐变定义，用于进度环 -->
        <svg width="0" height="0">
            <defs>
                <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stop-color="#a78bfa" />   <!-- 浅紫色 -->
                    <stop offset="50%" stop-color="#8b5cf6" />  <!-- 中紫色 -->
                    <stop offset="100%" stop-color="#7c3aed" /> <!-- 深紫色 -->
                </linearGradient>
            </defs>
        </svg>
        
        <!-- 冥想模式标题区域 -->
        <div class="text-center mb-12">
            <h2 id="medTitle" class="text-3xl font-cinzel text-amber-100 mb-4">深层冥想</h2>
            <p id="medDesc" class="text-sm text-amber-100/70 max-w-xs mx-auto leading-relaxed font-serif">
                闭上眼睛，专注于你心中的疑虑。<br>按住圆环，保持冥想 30 秒...
            </p>
        </div>
        
        <!-- 冥想圆环交互区域 -->
        <div id="meditationCircle" class="meditation-circle" role="button" aria-label="冥想圆环" tabindex="0">
            <!-- 进度环SVG -->
            <svg class="progress-ring">
                <circle cx="114" cy="114" r="110"></circle>
            </svg>
            <!-- 圆环中心文字 -->
            <div class="text-amber-100/90 font-cinzel text-xl tracking-widest pointer-events-none select-none">
                HOLD
            </div>
        </div>
        
        <!-- 冥想控制区域 -->
        <div class="mt-8 text-center">
            <!-- 倒计时显示 -->
            <div id="countdown" class="text-amber-100/50 text-sm mb-8 font-mono">30.0s</div>
            <!-- 返回按钮 -->
            <button id="closeMeditation" 
                    class="text-amber-100/40 hover:text-amber-100 text-sm uppercase tracking-widest transition-colors px-4 py-2 rounded border border-amber-900/20 hover:border-amber-900/40">
                返回 / Cancel
            </button>
        </div>
    </div>

    <script>
        // ============================================
        // AI预言生成器 - 主应用模块
        // 使用IIFE（立即调用函数表达式）封装，避免全局变量污染
        // ============================================
        const AIProphecyGenerator = (function() {
            // ============================================
            // 配置常量 - 集中管理所有可配置参数
            // ============================================
            const CONFIG = {
                // 冥想时间设置（毫秒）
                meditationTime: 30000, // 30秒
                
                // UI更新间隔（毫秒）
                updateInterval: 50,
                
                // 输入框最大字符数
                maxInputLength: 200,
                
                // 字符集配置
                charSet: {
                    // 英文元音字母
                    vowels: ['a', 'e', 'i', 'o', 'u'],
                    
                    // 英文辅音字母（排除元音）
                    consonants: [
                        'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 
                        'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'z'
                    ],
                    
                    // 英文常见字母组合（用于更自然的单词生成）
                    clusters: [
                        'str', 'spr', 'scr', 'chr', 'thr', 'spl', 'sch',
                        'th', 'sh', 'ch', 'ph', 'wh', 'bl', 'cl', 'fl', 'gl', 'pl', 'sl', 
                        'br', 'cr', 'dr', 'fr', 'gr', 'pr', 'tr', 'sc', 'sk', 'sm', 'sn', 
                        'sp', 'st', 'sw', 'tw', 'qu', 'wr', 'kn', 'gn', 'ck', 'ng'
                    ],
                    
                    // 常用中文字符集（约500个常用汉字）
                    chineseChars: "的一是在不了有和人这中大为上个国我以要他时来用们生到作地于出就分对成会可主发年动同工也能下过子说产种面而方后多定行学法所民得经十三之进着等部度家电力里如水化高自二理起小物现实量都两体制机当使点从业本去把性好应开它合还因由其些然前外天政四日那社义事平形相全表间样与关各重新线内数正心反你明看原又么利比或但质气第向道命此变条只没结解问意建月公无系军很情者最立代想已通并提直题党程展五果料象员革位入常文总次品式活设及管特件长求老头基资边流路级少员机山心压员感"
                },
                
                // 多语言文本配置
                texts: {
                    // 英语文本
                    en: {
                        inputLabel: '"Please express your doubts here..."',
                        placeholder: "Enter your question here...",
                        generateBtn: "SEEK PROPHECY",
                        medTitle: "Deep Reflection",
                        medDesc: "Close your eyes, focus on your question.<br>Hold the circle to meditate for 30 seconds...",
                        medBack: "Return / Cancel",
                        prophecyLabel: "The Prophecy",
                        instruction: 'Use this text to generate images, they will contain your revelation.',
                        tip: '* Older AI models generate better images because they are fuzzy enough and do not optimize prompts.',
                        copyBtn: "Copy Prophecy",
                        resetBtn: "Ask Again"
                    },
                    
                    // 中文文本
                    cn: {
                        inputLabel: '"请在此表达你心中的疑虑..."',
                        placeholder: "在此输入你的问题...",
                        generateBtn: "寻求启示",
                        medTitle: "深层冥想",
                        medDesc: "闭上眼睛，专注于你心中的疑虑。<br>按住圆环，保持冥想 30 秒...",
                        medBack: "返回 / Cancel",
                        prophecyLabel: "天启之言",
                        instruction: '"去用这串文字生成图片，它们将蕴藏你的启示。"',
                        tip: '* 用较旧的AI模型生成图片效果更佳，因为它们足够模糊，并且不会优化提示词。',
                        copyBtn: "复制预言",
                        resetBtn: "再次提问"
                    }
                }
            };

            // ============================================
            // 应用状态管理
            // ============================================
            let state = {
                language: 'cn',              // 当前语言：'en' 或 'cn'
                isMeditating: false,         // 是否正在冥想
                meditationProgress: 0,       // 冥想进度（0-1）
                audioContext: null,          // Web Audio API 上下文
                audioNodes: [],              // 音频节点集合
                particles: [],               // 粒子对象数组
                lastAnimationFrame: 0        // 上一帧动画时间戳
            };

            // ============================================
            // DOM 元素缓存对象
            // ============================================
            const elements = {};

            // ============================================
            // 初始化函数 - 应用启动入口
            // ============================================
            function init() {
                cacheElements();        // 缓存DOM元素引用
                initEventListeners();   // 初始化事件监听器
                initParticles();        // 初始化粒子背景
                setLanguage(state.language); // 设置初始语言
                updateCharCount();      // 初始化字符计数器
            }

            // ============================================
            // DOM元素缓存函数
            // 获取并存储所有需要频繁访问的DOM元素
            // ============================================
            function cacheElements() {
                // 需要缓存的元素ID列表
                const ids = [
                    'userInput', 'generateBtn', 'resetBtn', 'copyBtn', 'inputLabel',
                    'input-section', 'output-section', 'resultText', 'langEnBtn',
                    'langCnBtn', 'langHighlight', 'meditateBtn', 'meditationOverlay',
                    'closeMeditation', 'meditationCircle', 'medTitle', 'medDesc',
                    'charCount', 'countdown'
                ];
                
                // 遍历ID列表，将元素存储到缓存对象
                ids.forEach(id => {
                    elements[id] = document.getElementById(id);
                });
                
                // 缓存特殊元素
                elements.progressCircle = elements.meditationCircle?.querySelector('circle');
                elements.closeMeditationText = elements.closeMeditation;
            }

            // ============================================
            // 事件监听器初始化
            // 绑定所有用户交互事件
            // ============================================
            function initEventListeners() {
                // 语言切换事件
                elements.langEnBtn.addEventListener('click', () => setLanguage('en'));
                elements.langCnBtn.addEventListener('click', () => setLanguage('cn'));
                
                // 生成预言按钮点击事件
                elements.generateBtn.addEventListener('click', handleGenerate);
                
                // 重置按钮点击事件
                elements.resetBtn.addEventListener('click', handleReset);
                
                // 复制按钮点击事件
                elements.copyBtn.addEventListener('click', handleCopy);
                
                // 冥想模式按钮点击事件
                elements.meditateBtn.addEventListener('click', openMeditation);
                elements.closeMeditation.addEventListener('click', closeMeditation);
                
                // 输入框字符计数事件
                elements.userInput.addEventListener('input', updateCharCount);
                
                // 全局键盘快捷键
                document.addEventListener('keydown', handleKeydown);
                
                // 冥想圆环交互事件
                const startEvents = ['mousedown', 'touchstart'];      // 开始事件
                const endEvents = ['mouseup', 'mouseleave', 'touchend', 'touchcancel']; // 结束事件
                
                // 绑定开始冥想事件
                startEvents.forEach(evt => {
                    elements.meditationCircle.addEventListener(evt, startMeditation, { passive: true });
                });
                
                // 绑定结束冥想事件
                endEvents.forEach(evt => {
                    elements.meditationCircle.addEventListener(evt, stopMeditation, { passive: true });
                });
                
                // 防止冥想圆环上的右键菜单
                elements.meditationCircle.addEventListener('contextmenu', e => e.preventDefault());
                
                // 窗口失焦时自动停止冥想
                window.addEventListener('blur', () => {
                    if (state.isMeditating) stopMeditation();
                });
            }

            // ============================================
            // 语言管理函数
            // ============================================

            /**
             * 设置应用语言
             * @param {string} lang - 语言代码：'en' 或 'cn'
             */
            function setLanguage(lang) {
                state.language = lang;      // 更新状态
                updateUIText();             // 更新界面文本
                updateLanguageToggle();     // 更新语言切换器UI
            }

            /**
             * 更新界面所有文本内容
             */
            function updateUIText() {
                const texts = CONFIG.texts[state.language];
                if (!texts) return;
                
                // 更新输入区域文本
                elements.inputLabel.textContent = texts.inputLabel;
                elements.userInput.placeholder = texts.placeholder;
                elements.generateBtn.textContent = texts.generateBtn;
                
                // 更新冥想模式文本
                elements.medTitle.textContent = texts.medTitle;
                elements.medDesc.innerHTML = texts.medDesc;
                elements.closeMeditation.textContent = texts.medBack;
                
                // 更新输出区域文本
                const prophecyLabel = elements.outputSection?.querySelector('p.text-xs');
                if (prophecyLabel) prophecyLabel.textContent = texts.prophecyLabel;
                
                const instruction = elements.outputSection?.querySelector('.text-sm.italic');
                if (instruction) instruction.textContent = texts.instruction;
                
                const tip = elements.outputSection?.querySelector('.text-xs.border-t');
                if (tip) tip.textContent = texts.tip;
                
                // 更新按钮文本
                elements.copyBtn.textContent = texts.copyBtn;
                elements.resetBtn.textContent = texts.resetBtn;
            }

            /**
             * 更新语言切换器的视觉状态
             */
            function updateLanguageToggle() {
                const isEnglish = state.language === 'en';
                
                // 移动高亮指示器
                elements.langHighlight.style.transform = isEnglish ? 'translateX(0)' : 'translateX(100%)';
                
                // 更新按钮文字颜色
                elements.langEnBtn.classList.toggle('text-amber-100/50', !isEnglish);
                elements.langEnBtn.classList.toggle('text-amber-100', isEnglish);
                elements.langCnBtn.classList.toggle('text-amber-100/50', isEnglish);
                elements.langCnBtn.classList.toggle('text-amber-100', !isEnglish);
            }

            // ============================================
            // 预言生成核心算法
            // ============================================

            /**
             * 从数组中随机选择一个元素
             * @param {Array} arr - 源数组
             * @param {any} exclude - 要排除的元素（可选）
             * @returns {any} 随机选择的元素
             */
            function getRandomItem(arr, exclude = null) {
                if (arr.length === 0) return '';
                if (arr.length === 1) return arr[0];
                
                let item;
                // 确保不返回被排除的元素（除非数组只有一个元素）
                do {
                    item = arr[Math.floor(Math.random() * arr.length)];
                } while (item === exclude && arr.length > 1);
                
                return item;
            }

            /**
             * 根据源字符的大小写模式调整目标字符的大小写
             * @param {string} source - 源字符
             * @param {string} target - 目标字符
             * @returns {string} 调整大小写后的目标字符
             */
            function matchCase(source, target) {
                if (!source || !target) return target;
                
                // 全大写模式
                if (source === source.toUpperCase()) {
                    return target.toUpperCase();
                }
                
                // 首字母大写模式
                if (source[0] === source[0].toUpperCase()) {
                    return target.charAt(0).toUpperCase() + target.slice(1).toLowerCase();
                }
                
                // 全小写模式
                return target.toLowerCase();
            }

            /**
             * 英文文本转换函数
             * 将输入的英文文本转换为神秘的"预言"文本
             * @param {string} text - 输入的英文文本
             * @returns {string} 转换后的预言文本
             */
            function transformEnglish(text) {
                let result = '';
                let i = 0;
                
                while (i < text.length) {
                    const char = text[i];
                    
                    // 非字母字符直接保留（空格、标点等）
                    if (!/[a-zA-Z]/.test(char)) {
                        result += char;
                        i++;
                        continue;
                    }
                    
                    const charLower = char.toLowerCase();
                    let replaced = false;
                    
                    // 优先检查字母组合（2-3个字符）
                    for (let len = 3; len >= 2; len--) {
                        if (i + len <= text.length) {
                            const chunk = text.substring(i, i + len);
                            const chunkLower = chunk.toLowerCase();
                            
                            // 如果找到匹配的字母组合
                            if (CONFIG.charSet.clusters.includes(chunkLower)) {
                                // 随机选择一个相同长度的替代组合
                                const replacement = getRandomItem(
                                    CONFIG.charSet.clusters.filter(c => c.length === len),
                                    chunkLower
                                );
                                result += matchCase(chunk, replacement);
                                i += len;
                                replaced = true;
                                break;
                            }
                        }
                    }
                    
                    // 如果没有替换字母组合，替换单个字符
                    if (!replaced) {
                        if (CONFIG.charSet.vowels.includes(charLower)) {
                            // 元音替换
                            result += matchCase(char, getRandomItem(CONFIG.charSet.vowels, charLower));
                        } else if (CONFIG.charSet.consonants.includes(charLower)) {
                            // 辅音替换
                            result += matchCase(char, getRandomItem(CONFIG.charSet.consonants, charLower));
                        } else {
                            // 非字母字符保留原样
                            result += char;
                        }
                        i++;
                    }
                }
                
                return result;
            }

            /**
             * 中文文本转换函数
             * 将输入的中文文本转换为神秘的"预言"文本
             * @param {string} text - 输入的中文文本
             * @returns {string} 转换后的预言文本
             */
            function transformChinese(text) {
                // 将每个中文字符替换为随机常用汉字
                return Array.from(text).map(char => {
                    if (/[\u4e00-\u9fa5]/.test(char)) {
                        return CONFIG.charSet.chineseChars[
                            Math.floor(Math.random() * CONFIG.charSet.chineseChars.length)
                        ];
                    }
                    return char; // 非中文字符保留原样
                }).join('');
            }

            /**
             * 根据语言生成随机预言文本
             * @param {string} lang - 语言代码：'en' 或 'cn'
             * @returns {string} 随机生成的预言文本
             */
            function generateRandomProphecy(lang) {
                return lang === 'en' 
                    ? generateRandomEnglishProphecy() 
                    : generateRandomChineseProphecy();
            }

            /**
             * 生成随机英文预言
             * 创建看似合理但无意义的英文短语
             * @returns {string} 随机英文预言
             */
            function generateRandomEnglishProphecy() {
                const wordCount = 8 + Math.floor(Math.random() * 8); // 8-15个单词
                const words = [];
                
                for (let i = 0; i < wordCount; i++) {
                    const length = 3 + Math.floor(Math.random() * 7); // 3-9个字母
                    let word = '';
                    let useVowel = Math.random() > 0.5; // 随机决定从元音还是辅音开始
                    
                    // 构建单词，交替使用元音和辅音
                    while (word.length < length) {
                        if (useVowel) {
                            word += getRandomItem(CONFIG.charSet.vowels);
                        } else {
                            // 30%的概率使用字母组合
                            if (Math.random() < 0.3 && length - word.length >= 2) {
                                const cluster = getRandomItem(
                                    CONFIG.charSet.clusters.filter(c => c.length <= 2)
                                );
                                word += cluster;
                            } else {
                                word += getRandomItem(CONFIG.charSet.consonants);
                            }
                        }
                        useVowel = !useVowel; // 切换元音/辅音
                    }
                    
                    // 第一个单词首字母大写
                    if (i === 0) {
                        word = word.charAt(0).toUpperCase() + word.slice(1);
                    }
                    
                    words.push(word);
                }
                
                return words.join(' ') + '.'; // 添加句号
            }

            /**
             * 生成随机中文预言
             * 创建看似合理但无意义的中文短语
             * @returns {string} 随机中文预言
             */
            function generateRandomChineseProphecy() {
                const length = 15 + Math.floor(Math.random() * 20); // 15-34个字符
                let result = '';
                let chunkLength = 0;
                let targetChunk = 3 + Math.floor(Math.random() * 4); // 3-6个字符为一段
                
                for (let i = 0; i < length; i++) {
                    result += getRandomItem(Array.from(CONFIG.charSet.chineseChars));
                    chunkLength++;
                    
                    // 按随机长度添加逗号分隔
                    if (chunkLength >= targetChunk && i < length - 1) {
                        result += '，';
                        chunkLength = 0;
                        targetChunk = 2 + Math.floor(Math.random() * 5); // 重新计算下一段长度
                    }
                }
                
                return result + '。'; // 添加句号
            }

            // ============================================
            // UI交互处理函数
            // ============================================

            /**
             * 处理生成预言按钮点击
             */
            function handleGenerate() {
                const input = elements.userInput.value.trim();
                
                // 输入验证
                if (!input) {
                    showNotification(
                        state.language === 'en' 
                            ? "Please enter your question" 
                            : "请输入你的问题"
                    );
                    return;
                }
                
                // 显示加载状态
                const originalText = elements.generateBtn.textContent;
                elements.generateBtn.innerHTML = 
                    state.language === 'en' 
                        ? '<span class="loading-dots">Consulting</span>' 
                        : '<span class="loading-dots">正在通灵</span>';
                elements.generateBtn.disabled = true;
                
                // 异步处理避免阻塞UI
                setTimeout(() => {
                    // 根据当前语言选择转换函数
                    const prophecy = state.language === 'en' 
                        ? transformEnglish(input) 
                        : transformChinese(input);
                    
                    showResult(prophecy);
                    
                    // 恢复按钮状态
                    elements.generateBtn.textContent = originalText;
                    elements.generateBtn.disabled = false;
                }, 800); // 800ms延迟，增加仪式感
            }

            /**
             * 显示预言结果
             * @param {string} text - 要显示的预言文本
             */
            function showResult(text) {
                elements.resultText.textContent = text;
                elements.inputSection.classList.add('hidden');      // 隐藏输入区域
                elements.outputSection.classList.remove('hidden'); // 显示结果区域
                
                // 平滑滚动到结果区域
                elements.outputSection.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'nearest' 
                });
            }

            /**
             * 重置应用状态，回到输入界面
             */
            function handleReset() {
                elements.outputSection.classList.add('hidden');
                elements.inputSection.classList.remove('hidden');
                elements.userInput.value = '';
                updateCharCount();
                elements.userInput.focus(); // 聚焦到输入框
            }

            /**
             * 复制预言文本到剪贴板
             */
            async function handleCopy() {
                const text = elements.resultText.textContent;
                if (!text) return;
                
                try {
                    // 使用现代剪贴板API
                    await navigator.clipboard.writeText(text);
                    showNotification(
                        state.language === 'en' 
                            ? "Prophecy copied!" 
                            : "预言已复制！"
                    );
                } catch (err) {
                    console.error('Copy failed:', err);
                    // 降级方案：使用传统execCommand
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showNotification("已复制到剪贴板");
                }
            }

            /**
             * 更新输入框字符计数器
             */
            function updateCharCount() {
                const count = elements.userInput.value.length;
                elements.charCount.textContent = count;
                
                // 超过限制时改变颜色
                elements.charCount.classList.toggle('text-red-400', count >= CONFIG.maxInputLength);
                
                // 强制限制字符数
                if (count > CONFIG.maxInputLength) {
                    elements.userInput.value = elements.userInput.value.substring(0, CONFIG.maxInputLength);
                    elements.charCount.textContent = CONFIG.maxInputLength;
                }
            }

            // ============================================
            // 冥想模式功能
            // ============================================

            /**
             * 打开冥想模式
             */
            function openMeditation() {
                elements.meditationOverlay.classList.add('active');
                elements.meditationOverlay.setAttribute('aria-hidden', 'false');
                document.body.style.overflow = 'hidden'; // 防止背景滚动
            }

            /**
             * 关闭冥想模式
             */
            function closeMeditation() {
                elements.meditationOverlay.classList.remove('active');
                elements.meditationOverlay.setAttribute('aria-hidden', 'true');
                document.body.style.overflow = ''; // 恢复滚动
                stopMeditation(); // 确保停止冥想
            }

            /**
             * 开始冥想计时
             * @param {Event} e - 触发事件
             */
            function startMeditation(e) {
                e.preventDefault();
                if (state.isMeditating) return;
                
                state.isMeditating = true;
                state.meditationProgress = 0;
                state.meditationStartTime = Date.now();
                
                // 更新UI状态
                elements.meditationCircle.querySelector('div').textContent = "HOLDING...";
                elements.meditationCircle.classList.add('scale-95');
                
                // 启动音频和环境音效
                initAudio();
                startMeditationAudio();
                
                // 开始更新进度
                updateMeditationProgress();
            }

            /**
             * 停止冥想
             */
            function stopMeditation() {
                if (!state.isMeditating) return;
                
                state.isMeditating = false;
                clearTimeout(state.meditationTimer);
                cancelAnimationFrame(state.animationFrame);
                
                // 重置UI
                elements.meditationCircle.querySelector('div').textContent = "HOLD";
                elements.meditationCircle.classList.remove('scale-95');
                elements.countdown.textContent = "30.0s";
                
                // 重置进度环
                if (elements.progressCircle) {
                    elements.progressCircle.style.strokeDashoffset = '690.8';
                }
                
                // 停止音频
                stopMeditationAudio();
            }

            /**
             * 更新冥想进度（使用requestAnimationFrame实现平滑动画）
             */
            function updateMeditationProgress() {
                if (!state.isMeditating) return;
                
                const elapsed = Date.now() - state.meditationStartTime;
                state.meditationProgress = Math.min(elapsed / CONFIG.meditationTime, 1);
                
                // 更新进度环视觉效果
                if (elements.progressCircle) {
                    const offset = 690.8 - (state.meditationProgress * 690.8);
                    elements.progressCircle.style.strokeDashoffset = offset;
                }
                
                // 更新倒计时显示
                const remaining = (CONFIG.meditationTime - elapsed) / 1000;
                elements.countdown.textContent = remaining > 0 
                    ? `${remaining.toFixed(1)}s` 
                    : "0.0s";
                
                // 检查是否完成
                if (state.meditationProgress >= 1) {
                    completeMeditation();
                    return;
                }
                
                // 继续下一帧更新
                state.animationFrame = requestAnimationFrame(updateMeditationProgress);
            }

            /**
             * 完成冥想，生成随机预言
             */
            function completeMeditation() {
                stopMeditation();
                closeMeditation();
                
                // 生成随机预言
                const prophecy = generateRandomProphecy(state.language);
                showResult(prophecy);
                
                // 触觉反馈（如果设备支持）
                if (navigator.vibrate) {
                    navigator.vibrate([100, 50, 100]); // 振动模式：100ms开，50ms关，100ms开
                }
            }

            // ============================================
            // 音频系统（Web Audio API）
            // ============================================

            /**
             * 初始化音频上下文
             */
            function initAudio() {
                if (!state.audioContext) {
                    state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // 如果音频上下文被挂起，恢复它
                if (state.audioContext.state === 'suspended') {
                    state.audioContext.resume();
                }
            }

            /**
             * 开始播放冥想环境音
             */
            function startMeditationAudio() {
                if (!state.audioContext) return;
                
                const ctx = state.audioContext;
                const masterGain = ctx.createGain();
                masterGain.gain.setValueAtTime(0.02, ctx.currentTime);
                masterGain.gain.exponentialRampToValueAtTime(0.1, ctx.currentTime + 2);
                masterGain.connect(ctx.destination);
                
                // 创建基础频率音调
                const frequencies = [
                    { freq: 110, type: 'sine', detune: 0 },   // A2 (低音基础)
                    { freq: 111, type: 'sine', detune: 10 },  // 轻微失谐，创造立体感
                    { freq: 55, type: 'triangle', detune: 0 } // A1 (低音八度)
                ];
                
                // 创建振荡器
                frequencies.forEach(({ freq, type, detune }) => {
                    const oscillator = ctx.createOscillator();
                    oscillator.type = type;
                    oscillator.frequency.value = freq;
                    oscillator.detune.value = detune;
                    oscillator.connect(masterGain);
                    oscillator.start();
                    state.audioNodes.push(oscillator);
                });
                
                // 创建低频振荡器（LFO）用于呼吸效果
                const lfo = ctx.createOscillator();
                lfo.type = 'sine';
                lfo.frequency.value = 0.15; // 每6.67秒一个周期
                
                const lfoGain = ctx.createGain();
                lfoGain.gain.value = 0.03; // 调制深度
                
                lfo.connect(lfoGain);
                lfoGain.connect(masterGain.gain);
                lfo.start();
                
                state.audioNodes.push(lfo, masterGain);
            }

            /**
             * 停止冥想音频
             */
            function stopMeditationAudio() {
                if (!state.audioContext || state.audioNodes.length === 0) return;
                
                const ctx = state.audioContext;
                const now = ctx.currentTime;
                
                // 淡出音频
                state.audioNodes.forEach(node => {
                    if (node.gain) {
                        node.gain.setTargetAtTime(0, now, 0.3);
                    }
                });
                
                // 延迟停止振荡器，避免爆音
                setTimeout(() => {
                    state.audioNodes.forEach(node => {
                        if (node.stop) node.stop();
                    });
                    state.audioNodes = [];
                }, 500);
            }

            // ============================================
            // 粒子背景系统
            // ============================================

            /**
             * 初始化粒子背景效果
             */
            function initParticles() {
                const particlesContainer = document.getElementById('particles');
                if (!particlesContainer) return;
                
                // 根据屏幕宽度计算粒子数量
                const particleCount = Math.floor(window.innerWidth / 20);
                
                // 创建粒子
                for (let i = 0; i < particleCount; i++) {
                    createParticle(particlesContainer);
                }
                
                // 开始动画循环
                animateParticles();
            }

            /**
             * 创建单个粒子
             * @param {HTMLElement} container - 粒子容器元素
             */
            function createParticle(container) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                
                // 随机位置
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.top = `${Math.random() * 100}%`;
                
                // 随机大小
                const size = 0.5 + Math.random() * 2;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                
                // 随机透明度
                particle.style.opacity = 0.1 + Math.random() * 0.3;
                
                // 随机动画延迟，创造错落有致的效果
                particle.style.animationDelay = `${Math.random() * 20}s`;
                
                // 随机动画持续时间
                particle.style.animationDuration = `${15 + Math.random() * 25}s`;
                
                container.appendChild(particle);
                state.particles.push({
                    element: particle,
                    speed: 0.5 + Math.random() * 1.5
                });
            }

            /**
             * 粒子动画循环
             */
            function animateParticles() {
                const now = Date.now();
                const delta = now - state.lastAnimationFrame;
                state.lastAnimationFrame = now;
                
                // 更新粒子位置
                state.particles.forEach(particle => {
                    const rect = particle.element.getBoundingClientRect();
                    // 如果粒子移出屏幕顶部，重置到底部
                    if (rect.top < -50) {
                        particle.element.style.top = '100%';
                        particle.element.style.left = `${Math.random() * 100}%`;
                    }
                });
                
                // 继续下一帧
                requestAnimationFrame(animateParticles);
            }

            // ============================================
            // 辅助功能函数
            // ============================================

            /**
             * 显示临时通知消息
             * @param {string} message - 通知消息
             * @param {number} duration - 显示时长（毫秒）
             */
            function showNotification(message, duration = 2000) {
                // 移除现有通知
                const existing = document.querySelector('.notification');
                if (existing) existing.remove();
                
                // 创建新通知元素
                const notification = document.createElement('div');
                notification.className = 'notification fixed top-4 right-4 bg-black/80 backdrop-blur-sm text-amber-100 px-4 py-3 rounded-lg border border-amber-900/30 shadow-lg z-50 transform transition-all duration-300 opacity-0 translate-y-2';
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                // 显示动画
                requestAnimationFrame(() => {
                    notification.classList.remove('opacity-0', 'translate-y-2');
                    notification.classList.add('opacity-100', 'translate-y-0');
                });
                
                // 定时隐藏
                setTimeout(() => {
                    notification.classList.remove('opacity-100', 'translate-y-0');
                    notification.classList.add('opacity-0', 'translate-y-2');
                    
                    // 动画结束后移除元素
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, duration);
            }

            /**
             * 处理键盘快捷键
             * @param {KeyboardEvent} e - 键盘事件
             */
            function handleKeydown(e) {
                // Ctrl/Cmd + Enter：快速生成预言
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    handleGenerate();
                }
                
                // Escape键：关闭冥想模式
                if (e.key === 'Escape') {
                    if (elements.meditationOverlay.classList.contains('active')) {
                        closeMeditation();
                    }
                }
            }

            // ============================================
            // 公共API - 暴露给外部调用的方法
            // ============================================
            return {
                init,                // 初始化应用
                setLanguage,         // 设置语言
                generateProphecy: handleGenerate, // 生成预言
                reset: handleReset   // 重置应用
            };
        })();

        // ============================================
        // 文档加载完成后初始化应用
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            AIProphecyGenerator.init();
            
            // 开发环境日志（可选）
            if (window.location.hostname === 'localhost') {
                console.log('AI Prophecy Generator initialized');
            }
        });

        // ============================================
        // Service Worker 注册（可选功能）
        // 启用后可将应用安装为PWA（渐进式Web应用）
        // ============================================
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').catch(err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
    </script>
</body>
</html>